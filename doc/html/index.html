<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Olagarro: Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Olagarro
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Olagarro utility library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="namespace_olagarro.html" title="Olagarro namespace: It contains Olagarro&#39;s all classes, functions, etc. ">Olagarro</a> is a C++ utility library which aims to provide small, easily usable, portable and useful utilities. Currently it only contains the concurrency module.</p>
<p>License is zlib/libpng (<a href="http://opensource.org/licenses/zlib-license.php">http://opensource.org/licenses/zlib-license.php</a>)</p>
<h1><a class="anchor" id="concurrency_sec"></a>
Concurrency module</h1>
<p>Concurrency module provides some facilities to take advantage of multiple CPUs of modern machines in a very easy and straightforward way. It uses futures paradigm in order to launch concurrent jobs or tasks in an unobstructive way. It is inspired by <a href="http://qt-project.org/doc/qt-5/qtconcurrent-index.html">Qt's concurrency module</a>.</p>
<p>It's written in C++ 2003 and does not use C++11 features in order to be able to offer its functionality in older compilers. Also in C++11 there is std::async so concurrency module would be redundant. In some way it can be seen as a C++ 2003 version of C++11's std::async.</p>
<h2><a class="anchor" id="Portability"></a>
Portability</h2>
<p>Concurrency module uses <a href="http://tinythreadpp.bitsnbites.eu/">TinyThread++</a> in order to have portable threads, so module is as portable as that library. It have been tested on Windows, Linux, Mac OS X and iOS.</p>
<h2><a class="anchor" id="Installation"></a>
Installation</h2>
<p>Module's installation is very easy: just unzip library somewhere in your project's tree and add .h and .cpp files to it in your IDE or project file. There is no need to build a library, configure it or something similar.</p>
<h2><a class="anchor" id="Examples"></a>
Examples</h2>
<p>Concurrency module is very easy to use. Here are some examples and it does not get more complicated. First we see how to launch a task in another thread:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;olagarro/concurrency.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">float</span> calculateSomeValue(<span class="keyword">const</span> std::vector&lt;float&gt;&amp; someData)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> valueResult = 0.0f;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    <span class="keywordflow">return</span> valueResult;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> otherFunction()</div>
<div class="line">{</div>
<div class="line">    std:vector&lt;float&gt; data(getSomeData());</div>
<div class="line"></div>
<div class="line">    Olagarro::Result&lt;float&gt; someValue = Olagarro::launchJob(calculateSomeValue, data);</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Result is = &quot;</span> &lt;&lt; someValue.result() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this example calculateSomeValue() runs in a different thread than calling code. Calling someValue.result() we block calling thread until calculateSomeValue() finishes its job or it just returns calculated value immediately if job has been done. This way using concurrency module we can launch jobs, do some other task while they are running in another threads and then ask for their result, blocking if its needed. No thread manual handling is required at all.</p>
<p>It is possible to launch any number of jobs: concurrency module will enqueue and process them as soon as it can, which is when a physical CPU core is free from a previous Job.</p>
<p>Other utility provided by concurrency module is concurrentFor, which spawns as many threads as machine's CPU core number:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;olagarro/concurrency.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> addOK(<span class="keywordtype">int</span> index, std::string&amp; str)</div>
<div class="line">{</div>
<div class="line">    str += <span class="stringliteral">&quot; OK&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> otherFunction()</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;std::string&gt; messages(getMessages());</div>
<div class="line"></div>
<div class="line">    Future&lt;void&gt; messagesFuture = Olagarro::concurrentFor(messages.begin(), messages.end(), addOK);</div>
<div class="line"></div>
<div class="line">    messagesFuture.result(); <span class="comment">// Block until all processing is done</span></div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;All strings processed\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this example we process a vector of strings. For each string a call is made to addOk() function, passing element's index and element itself to it. If that code runs in a machine with 4 CPUs, messages vector will be split in 4 parts and each part will be processed in its own thread. concurrentFor() call is no blocking, so we need a Future in order to know when it has finished its job.</p>
<p>These two examples summarize what concurrency module can do. There are other versions which take methods or functors instead of functions but everything falls in one of these two categories.</p>
<h2><a class="anchor" id="raceconds"></a>
Race conditions</h2>
<p>If we are using for example a std::vector&lt;int&gt; in a function which modifies it and we call it with launchJob or concurrentFor, this std::vector&lt;int&gt; variable will be modified in another one or more threads. The calling thread should not modify it at the same time because concurrency module takes no care avoiding data races. That is, no locking or synchronization job is done so use this module with totally independent tasks. In the case of concurrentFor the std::vector&lt;int&gt; would be split in several chunks. Function assumes each element of the vector can be processed on its own, without the intervention of the other elements of the vector.</p>
<h2><a class="anchor" id="Performance"></a>
Performance</h2>
<p>This concurrency module nor any other concurrency library will offer a "magical" performance boost to your code. Sometimes serial code will be faster (even by several orders of magnitude) than concurrent one due to the type of calculations, memory access, etc you are doing. Concurrency only makes sense when you have heavy tasks which take much more time doing its job than managing its launching, or to avoid blocking some important thread (like GUI thread in a typical desktop application). Fortunately concurrency module is very unobstructive so you can easily make your code take advantage of its facilities, profile your new code and see if it's worth or not to go concurrent.</p>
<h2><a class="anchor" id="Implementation"></a>
Implementation details</h2>
<p>Concurrency module manages a thread pool under the hood. This pool contains several threads blocked, waiting for new tasks. When launchJob() or concurrentFor() is called, those functions create tasks and enqueue them in the task queue. This way tasks are executed in sequential order (first in first executed) but due to their asynchronous nature they finish in a non-ordered fashion. Be careful: concurrency module is not designed to have nested tasks. In other words, it's dangerous that a function launched by launchJob() makes a call to launchJob(), thread pool could get blocked forever. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Aug 16 2014 18:25:35 for Olagarro by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
